<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>redis 五种数据类型的简单介绍和使用 | TeaHub</title><meta name="description" content="[TOC] 1.Redis 特性 速度快 正常情况下，Redis 读写性能可以达到 10 万&#x2F;秒 ；Redis 所有数据是存放在内存中的、Redis 是用 C 语言实现的、Redis 使用了单线程架构。  基于键值对的数据结构 Redis 的全称是 REmote Dictionary Server，主要提供了 5 种数据结构：字符串(String)、哈希(Hash)、列表(List)、集合(Set"><meta name="keywords" content="redis"><meta name="author" content="Gy"><meta name="copyright" content="Gy"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="dns-prefetch" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="dns-prefetch" href="https://fonts.googleapis.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="dns-prefetch" href="//busuanzi.ibruce.info"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="redis 五种数据类型的简单介绍和使用"><meta name="twitter:description" content="[TOC] 1.Redis 特性 速度快 正常情况下，Redis 读写性能可以达到 10 万&#x2F;秒 ；Redis 所有数据是存放在内存中的、Redis 是用 C 语言实现的、Redis 使用了单线程架构。  基于键值对的数据结构 Redis 的全称是 REmote Dictionary Server，主要提供了 5 种数据结构：字符串(String)、哈希(Hash)、列表(List)、集合(Set"><meta name="twitter:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="og:type" content="article"><meta property="og:title" content="redis 五种数据类型的简单介绍和使用"><meta property="og:url" content="http://teahub.store/2020/05/19/redis/"><meta property="og:site_name" content="TeaHub"><meta property="og:description" content="[TOC] 1.Redis 特性 速度快 正常情况下，Redis 读写性能可以达到 10 万&#x2F;秒 ；Redis 所有数据是存放在内存中的、Redis 是用 C 语言实现的、Redis 使用了单线程架构。  基于键值对的数据结构 Redis 的全称是 REmote Dictionary Server，主要提供了 5 种数据结构：字符串(String)、哈希(Hash)、列表(List)、集合(Set"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-05-19T11:23:17.000Z"><meta property="article:modified_time" content="2020-05-19T11:30:08.207Z"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://teahub.store/2020/05/19/redis/"><link rel="next" title="git 简介以及使用" href="http://teahub.store/2020/05/15/git/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'false',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">2</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">2</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-Redis-特性"><span class="toc-number">1.</span> <span class="toc-text">1.Redis 特性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-Redis-API的理解与使用"><span class="toc-number">2.</span> <span class="toc-text">2.Redis API的理解与使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-全局命令"><span class="toc-number">2.1.</span> <span class="toc-text">1.全局命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-数据结构和内部编码"><span class="toc-number">2.2.</span> <span class="toc-text">2.数据结构和内部编码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-字符串"><span class="toc-number">2.2.1.</span> <span class="toc-text">1.字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-哈希"><span class="toc-number">2.2.2.</span> <span class="toc-text">2.哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-列表"><span class="toc-number">2.2.3.</span> <span class="toc-text">3.列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-集合"><span class="toc-number">2.2.4.</span> <span class="toc-text">4.集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-有序集合"><span class="toc-number">2.2.5.</span> <span class="toc-text">5.有序集合</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">TeaHub</a></span><span class="pull_right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> About</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> List</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> Music</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> Movie</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">redis 五种数据类型的简单介绍和使用</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-05-19 19:23:17"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-05-19</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-05-19 19:30:08"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2020-05-19</span></time></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>[TOC]</p>
<h2 id="1-Redis-特性"><a href="#1-Redis-特性" class="headerlink" title="1.Redis 特性"></a>1.Redis 特性</h2><ol>
<li><p><strong>速度快</strong></p>
<p>正常情况下，Redis 读写性能可以达到 10 万/秒 ；Redis 所有数据是存放在内存中的、Redis 是用 C 语言实现的、Redis 使用了单线程架构。</p>
</li>
<li><p><strong>基于键值对的数据结构</strong></p>
<p>Redis 的全称是 REmote Dictionary Server，主要提供了 <code>5</code> 种数据结构：<code>字符串(String)</code>、<code>哈希(Hash)</code>、<code>列表(List)</code>、<code>集合(Set)</code>、<code>有序集合(ZSet)</code>。</p>
<p>在字符串的基础上演变出了<code>位图(Bitmaps)</code>、<code>HyperLogLog</code>两种数据机构，在 Redis3.2 版本中加入有关<code>GEO(地理信息定位)</code>的功能。</p>
</li>
<li><p><strong>丰富的功能</strong></p>
<ul>
<li>提供了键过期功能，可以用来实现缓存</li>
<li>提供了发布订阅功能，可以用来实现消息系统</li>
<li>支持Lua脚本功能，可以利用Lua创造出新的Redis命令</li>
<li>提供了简单的事务功能，能在一定程度上保证事务特性</li>
<li>提供了（Pipeline）功能，这样客户点能将一批命令一次性传到 Redis ，减少了网络的开销</li>
</ul>
</li>
<li><p><strong>简单稳定</strong></p>
</li>
<li><p><strong>客户端语言多</strong></p>
</li>
<li><p><strong>持久化</strong></p>
<p>将数据放在内存中是不安全的，一旦发生断电或者机器故障，重要的数据可能就会丢失，因此，Redis 提供了两种持久化方式：<code>RDB</code>和<code>AOF</code>，即可以用两种策略将内存的数据保存到硬盘中。</p>
</li>
<li><p><strong>主从复制</strong></p>
<p>Redis 提供了复制功能，实现了多个相同数据的 Redis 副本。</p>
</li>
<li><p><strong>高可用和分布式</strong></p>
<p>Redis 从2.8版本正式提供了高可用实现 Redis Sentinel，它能够保证 Redis 节点的故障发现和故障自动转移。Redis 从3.0版本正式提供了分布式实现 Redis Cluster，它是 Redis 真正的分布式实现，提供了高可用、读写和容量的扩展性。</p>
</li>
</ol>
<h2 id="2-Redis-API的理解与使用"><a href="#2-Redis-API的理解与使用" class="headerlink" title="2.Redis API的理解与使用"></a>2.Redis API的理解与使用</h2><h3 id="1-全局命令"><a href="#1-全局命令" class="headerlink" title="1.全局命令"></a>1.<strong>全局命令</strong></h3><ul>
<li><p><strong>查看所有键</strong></p>
<p><code>keys *</code>  会将所有的键输出</p>
</li>
<li><p><strong>键总数</strong></p>
<p><code>dbsize</code> 返回当前数据库中键的总数。  dbsize 命令在计算键总数时不会遍历所有键，而是直接获取Redis 内置的键总数变量，所以dbsize命令的时间复杂度是o(1)。而keys命令会遍历所有键，所以它的时间复杂度是o(n)，当Redis中保存了大量键时，<strong>线上环境禁止使用</strong>。</p>
</li>
<li><p><strong>检查键是否存在</strong></p>
<p><code>exists key</code>  如果存在则返回1，不存在则返回0。</p>
</li>
<li><p><strong>删除键</strong></p>
<p><code>del key [key ...]</code>  返回结果为成功删除键的个数，假设删除一个不存在的键，就会返回0</p>
</li>
<li><p><strong>键过期</strong></p>
<p><code>expire key seconds</code>  Redis 支持对键添加过期时间，当超过期时间后，会自动删除键。</p>
<p><code>ttl key</code> 返回键的剩余过期时间，有3中返回值</p>
<ul>
<li>大于等于0的整数：键剩余的过期时间</li>
<li>-1：键没设置过期时间</li>
<li>-2：键不存在</li>
</ul>
</li>
<li><p><strong>键的数据结构类型</strong></p>
<p><code>type key</code> 例如键是字符串类型，返回结果为string，键是列表类型，返回结果为list，如果键不存在，返回 none</p>
</li>
</ul>
<h3 id="2-数据结构和内部编码"><a href="#2-数据结构和内部编码" class="headerlink" title="2.数据结构和内部编码"></a>2.<strong>数据结构和内部编码</strong></h3><p><code>type</code> 命令实际返回的是当前键的数据结构类型（5种数据类型），但这些只是Redis对外的数据结构。</p>
<p>实际上每种数据结构都有自己底层的内部编码实现，而且是多种实现，这样Redis会在合适的场景选择合适的内部编码</p>
<p>我们可以通过<code>object encoding key</code>查询内部编码。</p>
<p><em>Redis 这样设计有2个好处：</em></p>
<ul>
<li>可以改进内部编码，而对外的数据结构和命令没有影响，这样一旦开发出更优秀的内部编码，无需改动外部数据结构和命令</li>
<li>多种内部编码实现可以不同场景下发挥各自的优势，例如ziplist比较节省内存，但是在列表元素比较多的情况下，性能会有所下降，这时候Redis会根据配置选项将列表类型的内部实现转换为linkedlist</li>
</ul>
<h4 id="1-字符串"><a href="#1-字符串" class="headerlink" title="1.字符串"></a>1.<strong>字符串</strong></h4><p>字符串类型是Redis最基础的数据结构。字符串的值<strong>最大不能超过512MB</strong></p>
<p><strong>命令</strong></p>
<ul>
<li><p><strong>设置值</strong></p>
<p><code>set key value [ex seconds] [px milliseconds] [nx|xx]</code> </p>
<ul>
<li>ex seconds：为键设置秒级过期时间</li>
<li>px milliseconds：为键设置毫秒级过期时间</li>
<li>nx：键必须不存在，才可以设置成功，用于添加</li>
<li>xx：与nx相反，键必须存在，才可以设置成功，用于更新</li>
</ul>
</li>
</ul>
<p>  除了 set 选项，Redis 还提供了 <code>setex</code> 和 <code>setnx</code> 两个命令，它们的作用和 ex 和 nx 选项是一样的：</p>
<ul>
<li><code>setex key seconds value</code></li>
<li><code>setnx key value</code></li>
</ul>
<ul>
<li><p><strong>获取值</strong></p>
<p><code>get key</code>  如果获取的键不存在，则返回nil（空） </p>
</li>
<li><p><strong>批量设置值</strong></p>
<p><code>mset key value [key value ...]</code></p>
</li>
<li><p><strong>批量获取值</strong></p>
<p><code>mget key [key ...]</code>  如果有些键不存在，那么它的值为nil（空），结果是按照传入键的顺序返回</p>
</li>
<li><p><strong>计数</strong></p>
<p><code>incr key</code> incr命令用于对值做自增的操作，返回结果分为<code>3</code>种情况：</p>
<ul>
<li>值不是整数，返回错误</li>
<li>值是整数，返回自增后的结果</li>
<li>键不存在，按照值为0自增，返回结果为1</li>
</ul>
</li>
</ul>
<p>  除了<code>incr</code>命令，Redis提供了<code>decr（自减）</code>、<code>incrby（自增指定数字）</code>、<code>decrby（自减指定数字）</code>、<code>incrbyfloat（自增浮点数）</code></p>
<ul>
<li><code>decr key</code></li>
<li><code>incrby key increment</code></li>
<li><code>decrby key decrement</code></li>
<li><code>incrbyfloat key increment</code></li>
</ul>
<ul>
<li><p><strong>追加值</strong></p>
<p><code>append key value</code>  append可以向字符串尾部追加值</p>
</li>
<li><p><strong>字符串长度</strong></p>
<p><code>strlen key</code>  eg：当前值为redisworld，所以返回值为10，当前值为世界，返回值为6（每个中文占用3个字节）</p>
</li>
<li><p><strong>设置并返回原值</strong></p>
<p><code>getset key value</code>  getset和set一样会设置值，但是不同的是，它同时会返回键原来的值</p>
</li>
<li><p><strong>设置指定位置的字符</strong></p>
<p><code>setrange key offset value</code> </p>
<ul>
<li><p>下面操作将值由pest变为了best</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> redis pest</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setrange redis 0 b</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line"><span class="string">"best"</span></span><br><span class="line">127.0.0.1:6379&gt; setrange redis 2  a</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line"><span class="string">"beat"</span></span><br><span class="line">127.0.0.1:6379&gt; setrange redis 6  c</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; get redis</span><br><span class="line"><span class="string">"beat\x00\x00c"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>获取部分字符串</strong></p>
<p><code>getrange key start end</code></p>
<p>start 和 end 分别是开始和结束的偏移量，偏移量从0开始计算</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; getrange redis 0 1</span><br><span class="line"><span class="string">"be"</span></span><br><span class="line">127.0.0.1:6379&gt; getrange redis 9 10</span><br><span class="line"><span class="string">""</span></span><br><span class="line">127.0.0.1:6379&gt; getrange redis 4 10</span><br><span class="line"><span class="string">"\x00\x00c"</span></span><br><span class="line">127.0.0.1:6379&gt; getrange redis 3 10</span><br><span class="line"><span class="string">"t\x00\x00c"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set key value</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">get key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">del key [key …]</td>
<td align="center">o(k)，k是键的个数</td>
</tr>
<tr>
<td align="center">mset key value [key value …]</td>
<td align="center">o(k)，k是键的个数</td>
</tr>
<tr>
<td align="center">mget key [key …]</td>
<td align="center">o(k)，k是键的个数</td>
</tr>
<tr>
<td align="center">incr key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">decr key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">incrby key increment</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">decrby key increment</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">incrbyfloat key increment</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">append key value</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">strlen key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">setrange key offset value</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">getrange key start end</td>
<td align="center">o(n)，n是字符串长度，由于获取字符串非常快，所以如果字符串不是很长，可以视同为o(1)</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="2-哈希"><a href="#2-哈希" class="headerlink" title="2.哈希"></a>2.<strong>哈希</strong></h4><p>在 Redis 中，哈希类型是指键值本身又是一个键值对结构。</p>
<p><strong>命令</strong></p>
<ul>
<li><p><strong>设置值</strong></p>
<p><code>hset key field value</code></p>
<p>下面为user:1 添加一对 field-value</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<p>如果field已经存在，执行上述命令返回 0，但实际的值发生改变</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name ddddd</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>此外，Redis 提供了<code>hsetnx</code> 命令，它们的关系就像set和setnx命令一样，只不过作用域由键变为field</p>
</li>
<li><p><strong>获取值</strong></p>
<p><code>hget key field</code></p>
<p>下面的操作获取user:1的name域（属性）对应的值，如果键或field不存在，会返回nil</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hget user:1  name</span><br><span class="line"><span class="string">"tom"</span></span><br><span class="line">127.0.0.1:6379&gt; hget user:1  namea</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除field</strong></p>
<p><code>hdel key field [field ...]</code></p>
<p>hedl 会删除一个或多个field，返回结果为成功删除field的个数</p>
</li>
<li><p><strong>计算field个数</strong></p>
<p><code>hlen key</code></p>
<p>例如：user:1 有3个field</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset user:1 name gy</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 age 26</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hset user:1 city hz</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hlen user1:1</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment">#key不存在返回值</span></span><br><span class="line">127.0.0.1:6379&gt; hlen user:1</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>批量设置或获取field-value</strong></p>
<p><code>hmset key field value [field value ...]</code></p>
<p><code>hmget key field [field...]</code></p>
<p>hmset和hmget分别是设置和获取field-value，hmset需要的参数是key和多对field-value，hmget需要的参数是key和多个field。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HMSET user:1 name huang age 12 city xian</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hmget user:1 name age citu city aa</span><br><span class="line">1) <span class="string">"huang"</span></span><br><span class="line">2) <span class="string">"12"</span></span><br><span class="line">3) (nil) <span class="comment">#field不存在</span></span><br><span class="line">4) <span class="string">"xian"</span></span><br><span class="line">5) (nil) <span class="comment">#field不存在</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>判断field是否存在</strong></p>
<p><code>hexists  key field</code></p>
<p>例如，user:1包含name域，所以返回结果为1，不包含时返回0</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; HEXISTS user:1 name22</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取所有field</strong></p>
<p><code>hkeys key</code></p>
<p>hkeys命令应该叫hfields更为恰当，他返回指定哈希键所有的field，例如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"age"</span></span><br><span class="line">3) <span class="string">"city"</span></span><br><span class="line">127.0.0.1:6379&gt; hkeys user:11  <span class="comment">#键不存在</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取所有value</strong></p>
<p><code>hvals key</code></p>
<p>获取 user:1全部value</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hvals user:1</span><br><span class="line">1) <span class="string">"huang"</span></span><br><span class="line">2) <span class="string">"12"</span></span><br><span class="line">3) <span class="string">"xian"</span></span><br><span class="line">127.0.0.1:6379&gt; hvals user:12</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取所有的field-value</strong></p>
<p><code>hgetall key</code></p>
<p>获取user:1所有的field-value</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall uset:1 <span class="comment">#key不存在的情况</span></span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; hgetall user:1</span><br><span class="line">1) <span class="string">"name"</span></span><br><span class="line">2) <span class="string">"huang"</span></span><br><span class="line">3) <span class="string">"age"</span></span><br><span class="line">4) <span class="string">"12"</span></span><br><span class="line">5) <span class="string">"city"</span></span><br><span class="line">6) <span class="string">"xian"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<p>在使用 hgetall时，如果哈希元素个数比较多，会存在阻塞 Redis 的可能。如果开发人员只需要获取部分field，可以使用hmget，如果一定要获取全部field-value，可以使用hscan命令，该命令会渐进式遍历哈希类型</p>
</li>
<li><p><strong>hincrby hincrbyfloat</strong></p>
<p><code>hincrby key field</code></p>
<p><code>hincrbyfloat key field</code></p>
<p>就像incrby、incrbyfloat命令一样，但是它们的作用域是field</p>
</li>
<li><p><strong>计算value的字符串长度（需要Redis 3.2以上）</strong></p>
<p><code>hstrlen key field</code></p>
<p>例如：hget user:1 name 的 value 是 tom，那么hstrlen 的返回结果就是3</p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">hset key field value</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">hget key field</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">hdel key field [field …]</td>
<td align="center">o(k)，k是field个数</td>
</tr>
<tr>
<td align="center">hlen key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">hgetall key</td>
<td align="center">o(n)，n是field总数</td>
</tr>
<tr>
<td align="center">hmget field [field …]</td>
<td align="center">o(k)，k是field的个数</td>
</tr>
<tr>
<td align="center">hmset field value [field value]</td>
<td align="center">o(k)，k是field的个数</td>
</tr>
<tr>
<td align="center">hexists key field</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">hkeys key</td>
<td align="center">o(n)，n是field总数</td>
</tr>
<tr>
<td align="center">hvals key</td>
<td align="center">o(n)，n是field总数</td>
</tr>
<tr>
<td align="center">hsetnx key field value</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">hincrby key field increment</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">hincrbyfloat key field increment</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">hstrlen key field</td>
<td align="center">o(1)</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.<strong>列表</strong></h4><p>列表（list）类型是用来存储多个有序的字符串。列表的每个字符串称为元素（element），一个列表最多可以存储2^32-1个元素。</p>
<p>在 Redis 中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。</p>
<p><strong>列表的四种操作类型</strong></p>
<table>
<thead>
<tr>
<th align="center">操作类型</th>
<th align="center">操作</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加</td>
<td align="center">rpush lpush linsert</td>
</tr>
<tr>
<td align="center">查询</td>
<td align="center">lrange lindex llen</td>
</tr>
<tr>
<td align="center">删除</td>
<td align="center">lpop rpop lrem ltrim</td>
</tr>
<tr>
<td align="center">修改</td>
<td align="center">lset</td>
</tr>
<tr>
<td align="center">阻塞操作</td>
<td align="center">bloop brpop</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>添加操作</strong></p>
<ul>
<li><p>从右边插入元素</p>
<p><code>rpush key value [value ...]</code></p>
<p>下面代码从右向左插入元素c、b、a：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush listkey c b a</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<p><code>lrange 0 -1</code>命令可以从左到右获取列表所有元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush listkey c b a </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpush listkey e f g <span class="comment">#左边插入</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; lrange listkey 0 -1</span><br><span class="line">1) <span class="string">"g"</span></span><br><span class="line">2) <span class="string">"f"</span></span><br><span class="line">3) <span class="string">"e"</span></span><br><span class="line">4) <span class="string">"c"</span></span><br><span class="line">5) <span class="string">"b"</span></span><br><span class="line">6) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; rrange listkey 0 -1</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `rrange`, with args beginning with: `listkey`, `0`, `-1`,</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从左边插入元素</strong></p>
<p><code>lpush key value [value ...]</code></p>
<p>使用方法和 rpush 相同，只不过从左侧插入</p>
</li>
<li><p><strong>向某个元素前或者后插入元素</strong></p>
<p><code>linsert key before|after pivot value</code></p>
<p>linsert 命令会从列表中找到等于 pivot（中枢） 的元素，在其前（before）或者后（after）插入一个 新的元素value。</p>
<p>下面操作将会在列表的元素b前插入java，返回结果为4，代表当前命令的长度</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush mylist c b a</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; linser mylist before b java</span><br><span class="line">(error) ERR unknown <span class="built_in">command</span> `linser`, with args beginning with: `mylist`, `before`, `b`, `java`, </span><br><span class="line">127.0.0.1:6379&gt; linsert mylist before b java</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>查找</strong></p>
<ul>
<li><p><strong>获取指定范围内的元素列表</strong></p>
<p><code>lrange key start end</code></p>
<p>lrange 操作会获取列表指定索引范围所有的元素。索引下标有两个特点：</p>
<ul>
<li><p>索引下标从左到右分别是0到N-1，但是从右到左分别是-1到-N</p>
</li>
<li><p>lrange中的 end  选项包含了自身，这个和很多编程语言不包含 end 不太相同，例如像获取列表的第 2 到 第 4 个元素，可以执行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 1 3</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; </span><br><span class="line"></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 7</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist -1 -3</span><br><span class="line">(empty list or <span class="built_in">set</span>)</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist -4 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist -5 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>获取列表指定索引下标的元素</strong></p>
<p><code>lindex key index</code></p>
<p>例如，当前列表最后一个元素为a：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex mylist -1</span><br><span class="line"><span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lindex mylist 0</span><br><span class="line"><span class="string">"c"</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>获取列表长度</strong></p>
<p><code>llen key</code></p>
<p>例如，下面表示当前列表长度为4</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; llen mylist</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; llen mylist2</span><br><span class="line">(<span class="built_in">integer</span>) 0  <span class="comment">#key值不存在返回的0</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>删除</strong></p>
<ul>
<li><p><strong>从列表左侧弹出元素</strong></p>
<p><code>lpop key</code></p>
<p>如下操作将列表最左侧的元素c会被弹出（弹出后，元素被删除），弹出后列表变为 java、b、a:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"b"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lpop mylist</span><br><span class="line"><span class="string">"c"</span>  <span class="comment">#弹出的元素</span></span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从列表右侧弹出</strong></p>
<p><code>rpop key</code></p>
<p>它的使用方法和lpop是一样的，只不过从列表右侧弹出。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; RPOP mylist</span><br><span class="line"><span class="string">"a"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除指定元素</strong></p>
<p><code>lrem key count value</code></p>
<p>lrem 命令会从列表中找到等于value的元素进行删除，根据count的不同分为三种情况：</p>
<ul>
<li><p>count&gt;0，从左到右，删除最多count个元素</p>
</li>
<li><p>count&lt;0，从右到左，删除最多count绝对值个元素</p>
</li>
<li><p>count=0，删除所有</p>
<p>例如，向列表从左向右插入5个a，下面操作将从列表左边开始删除4个为a的元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist a a a a a java a </span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br><span class="line">5) <span class="string">"a"</span></span><br><span class="line">6) <span class="string">"a"</span></span><br><span class="line">7) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lrem list 4 a</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; lrem mylist 4 a</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>按照索引范围修建列表</strong></p>
<p><code>ltrim key start  end</code></p>
<p>例如，下面操作会只保留列表mylist第2个到第4个元素</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist a a a a a java a </span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"java"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br><span class="line">4) <span class="string">"a"</span></span><br><span class="line">5) <span class="string">"a"</span></span><br><span class="line">6) <span class="string">"a"</span></span><br><span class="line">7) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; ltrim mylist 1 3</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>修改</strong></p>
<ul>
<li><p><strong>修改指定索引下标的元素</strong></p>
<p><code>lset key index newValue</code></p>
<p>下面操作会将列表listkey中的第3个元素设置为python:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">3) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; lset mylist 2 python</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; lrange mylist 0 -1</span><br><span class="line">1) <span class="string">"java"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">3) <span class="string">"python"</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>阻塞操作</strong></p>
<p>阻塞式弹出如下：</p>
<p><code>blpop key [key ...]（多个列表的键） timeout（阻塞时间&gt;=0）</code></p>
<p><code>brpop key [key ...] （多个列表的键）timeout（阻塞时间&gt;=0）</code></p>
<p>blpop和brpop 是 lpop 和 rpop 的阻塞版本</p>
<ul>
<li><p>列表为空：如果timeout=3，那么客服端要等到3秒后返回，如果timeout=0，那么客户端一直阻塞等待下去</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; brpop list:<span class="built_in">test</span> 3</span><br><span class="line">(nil)</span><br><span class="line">(3.05s)</span><br><span class="line">127.0.0.1:6379&gt; brpop list:<span class="built_in">test</span> 0  <span class="comment">#命令执行完成后去客户端新增该键值对数据，客户端立即返回</span></span><br><span class="line">1) <span class="string">"list:test"</span></span><br><span class="line">2) <span class="string">"ggggg"</span></span><br><span class="line">(34.77s)</span><br></pre></td></tr></table></figure>

<p><strong>列表命令时间复杂度</strong></p>
<table>
<thead>
<tr>
<th align="center">操作类型</th>
<th align="center">命令</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">添加</td>
<td align="center">rpush key value [value …]</td>
<td align="center">o(k)，k是元素的个数</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lpush key value [value …]</td>
<td align="center">o(k)，k是元素的个数</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">linsert key before|after pivot value</td>
<td align="center">o(n)，n是pivot距离列表头或尾的距离</td>
</tr>
<tr>
<td align="center">查找</td>
<td align="center">lrange key start end</td>
<td align="center">o(s+n)，s是start偏移量，n是start到end的范围</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lindex key index</td>
<td align="center">o(n)，n是索引的偏移量</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">llen key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center">删除</td>
<td align="center">lpop key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">rpop key</td>
<td align="center">o(1)</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">lrem count value</td>
<td align="center">o(n)，n是列表的长度</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">ltrim key start end</td>
<td align="center">o(n)，n是要裁剪的元素总数</td>
</tr>
<tr>
<td align="center">修改</td>
<td align="center">lset key index value</td>
<td align="center">o(n)，n是索引的偏移量</td>
</tr>
<tr>
<td align="center">阻塞操作</td>
<td align="center">blpop brpop</td>
<td align="center">o(1)</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
</ul>
<h4 id="4-集合"><a href="#4-集合" class="headerlink" title="4.集合"></a>4.集合</h4><p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。一个集合最多可以存储2^32-1个元素。</p>
<p>Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集。</p>
<p><strong>命令</strong></p>
<ul>
<li><p><strong>集合内操作</strong></p>
<ul>
<li><p><strong>添加元素</strong></p>
<p><code>sadd key member [member  ...]</code>  返回结果为添加成功的元素个数。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; EXISTS myset</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a b c </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; sadd myset a b</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除元素</strong></p>
<p><code>srem key member [member ...]</code>  返回结果为成功删除元素的个数</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem myset a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; srem myset hello</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算元素个数</strong></p>
<p><code>scard key</code>  scard 的时间复查度为O(1)，它不会遍历集合所有元素，而是直接使用 Redis 内部的变量</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>判断元素是否在集合中</strong></p>
<p><code>sismember key element</code>   如果给定元素element在集合内返回1，反之返回0</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember myset a <span class="comment">#不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; sismember myset c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; sismember myset1 c <span class="comment">#不存在</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>随机从集合返回指定个数元素</strong></p>
<p><code>srandmember key [count]</code>  [count]是可选参数，如果不写默认为1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset a b c </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"a"</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br><span class="line">127.0.0.1:6379&gt; srandmember myset 2</span><br><span class="line">1) <span class="string">"a"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>从集合随机弹出元素</strong></p>
<p><code>spop key [count]</code>   spop操作可以从集合中随机弹出一个元素</p>
<p>srandmember 和 spop 都是随机从集合中选出元素，两者不同的是spop命令执行后，元素会从集合中删除，而srandmember不会</p>
</li>
<li><p><strong>获取所有元素</strong></p>
<p><code>smembers key</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) <span class="string">"c"</span></span><br><span class="line">2) <span class="string">"b"</span></span><br></pre></td></tr></table></figure>

<p>smembers、lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用sscan来完成。</p>
</li>
</ul>
</li>
<li><p><strong>集合间操作</strong></p>
<ul>
<li><p><strong>求多个集合的交集</strong></p>
<p><code>sinter key [key ...]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd user:1:follow it music his sports</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sadd user:2:follow it news ent sprots</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; sinter user:1:follow user:2:follow</span><br><span class="line">1) <span class="string">"it"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>求多个集合的并集</strong></p>
<p><code>sunion key [key ...]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUNION user:1:follow user:2:follow</span><br><span class="line">1) <span class="string">"sports"</span></span><br><span class="line">2) <span class="string">"it"</span></span><br><span class="line">3) <span class="string">"his"</span></span><br><span class="line">4) <span class="string">"news"</span></span><br><span class="line">5) <span class="string">"ent"</span></span><br><span class="line">6) <span class="string">"music"</span></span><br><span class="line">7) <span class="string">"sprots"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>求多个集合的差集</strong></p>
<p><code>sdiff key [key ...]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sdiff user:1:follow user:2:follow</span><br><span class="line">1) <span class="string">"music"</span></span><br><span class="line">2) <span class="string">"his"</span></span><br><span class="line">3) <span class="string">"sports"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>将交集、并集、差集的结果保存</strong></p>
<p><code>sinterstore destination key [key ...]</code></p>
<p><code>sunionstore destination key [key ...]</code></p>
<p><code>sdiffstore destination key [key ...]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SINTERSTORE user:1_2:inter user:1:follow user:2:follow</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> user:1_2:inter</span><br><span class="line"><span class="built_in">set</span></span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS user:1_2:inter</span><br><span class="line">1) <span class="string">"it"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>集合常用命令时间复杂度</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">sadd key member [member …]</td>
<td align="center">O(k)，k是元素个数</td>
</tr>
<tr>
<td align="center">srem key member [member …]</td>
<td align="center">O(k)，k是元素个数</td>
</tr>
<tr>
<td align="center">scard key</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">sismember key member</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">srandmember key [count]</td>
<td align="center">O(count)</td>
</tr>
<tr>
<td align="center">spop key</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">smembers key</td>
<td align="center">O(n)，n是元素总数</td>
</tr>
<tr>
<td align="center">sinter key [key …]  || sinterstore</td>
<td align="center">O(m*k)，k是多个集合中元素最少的个数，m是键个数</td>
</tr>
<tr>
<td align="center">sunion key [key …]  || sunionstore</td>
<td align="center">O(k)，k是多个集合元素个数和</td>
</tr>
<tr>
<td align="center">sdiff key [key …]  || sdiffstore</td>
<td align="center">O(k)，k是多个集合元素个数和</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="5-有序集合"><a href="#5-有序集合" class="headerlink" title="5.有序集合"></a>5.有序集合</h4><p>它保留了集合不能有重复成员的特性，增加了有序集合的元素可以排序。但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为培训的依据。</p>
<p><strong>列表、集合、有序集合三者的异同点</strong></p>
<table>
<thead>
<tr>
<th align="center">数据结构</th>
<th align="center">是否允许重复元素</th>
<th align="center">是否有序</th>
<th align="center">有序实现方式</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">列表</td>
<td align="center">是</td>
<td align="center">是</td>
<td align="center">索引下标</td>
<td align="center">时间轴、消息队列等</td>
</tr>
<tr>
<td align="center">集合</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center">无</td>
<td align="center">标签、社交等</td>
</tr>
<tr>
<td align="center">有序集合</td>
<td align="center">否</td>
<td align="center">是</td>
<td align="center">分值（score）</td>
<td align="center">排行榜系统、社交等</td>
</tr>
</tbody></table>
<p><strong>命令</strong></p>
<ul>
<li><p><strong>集合内</strong></p>
<ul>
<li><p><strong>添加成员</strong></p>
<p><code>zadd key score member [score member ...]</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd user:ranking 251 tom</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zadd user:ranking 251 tom</span><br><span class="line">(<span class="built_in">integer</span>) 0 <span class="comment">#返回结果代表成功添加成员的个数</span></span><br></pre></td></tr></table></figure>

<p>有关zadd命令有2点需要注意：</p>
<p>Redis 3.2 为 zadd 命令添加了nx、xx、ch、incr四个选项</p>
<ul>
<li>nx：member必须不存在，才可以设置成功，用于添加</li>
<li>xx：member必须存在，才可以设置成功，用于更新</li>
<li>ch：返回此次操作后，有序集合元素和分数发生变化的个数</li>
<li>incr：对score做增加，相当于后面介绍的zincrby</li>
</ul>
<p>有序集合相比集合提供了排序字段，但是也产生了代价，zadd的时间复杂度为O(log(n))，sadd的时间复杂度为O(1)。</p>
</li>
<li><p><strong>计算成员个数</strong></p>
<p><code>zcard key</code></p>
</li>
<li><p><strong>计算某个成员的分数</strong></p>
<p><code>zscore key member</code>  </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZSCORE user:ranking tom</span><br><span class="line"><span class="string">"252"</span></span><br><span class="line">127.0.0.1:6379&gt; ZSCORE user:ranking tomss</span><br><span class="line">(nil)  <span class="comment">#如果成员不存在返回nil</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>计算成员的排名</strong></p>
<p><code>zrank key member</code>   分数低到高返回排名（排序从0开始计算）</p>
<p><code>zrevrank key member</code> 分数从高到低返回排名（排序从0开始计算）</p>
</li>
<li><p><strong>删除成员</strong></p>
<p><code>zrem key member [member...]</code> </p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrem user:ranking mike</span><br><span class="line">(<span class="built_in">integer</span>) 1 <span class="comment">#返回结果为成功删除的个数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>增加成员的分数</strong></p>
<p><code>zincrby key increment member</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zscore user:ranking tom</span><br><span class="line"><span class="string">"252"</span>  <span class="comment">#当前数据库中的分数</span></span><br><span class="line">127.0.0.1:6379&gt; zincrby user:ranking 8 tom</span><br><span class="line"><span class="string">"260"</span> <span class="comment">#增加8分后返回的结果</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回指定排名范围的成员</strong></p>
<p><code>zrange key start end [withscores]</code></p>
<p><code>zrevrange key start end [withscores]</code></p>
<p>有序集合是按照分值排名的，zrange是从低到高返回，zrevrange反之。</p>
<p>如果加上 withscores选项，同时会返回成员的分数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGE  user:ranking 0 2   <span class="comment">#返回排名最低的3个成员</span></span><br><span class="line">1) <span class="string">"kris"</span></span><br><span class="line">2) <span class="string">"frank"</span></span><br><span class="line">3) <span class="string">"tim"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGE  user:ranking 0 2 withscores</span><br><span class="line">1) <span class="string">"kris"</span></span><br><span class="line">2) <span class="string">"1"</span></span><br><span class="line">3) <span class="string">"frank"</span></span><br><span class="line">4) <span class="string">"200"</span></span><br><span class="line">5) <span class="string">"tim"</span></span><br><span class="line">6) <span class="string">"220"</span></span><br><span class="line">127.0.0.1:6379&gt; ZREVRANGE  user:ranking 0 2 withscores</span><br><span class="line">1) <span class="string">"tom"</span></span><br><span class="line">2) <span class="string">"260"</span></span><br><span class="line">3) <span class="string">"tom3"</span></span><br><span class="line">4) <span class="string">"252"</span></span><br><span class="line">5) <span class="string">"martin"</span></span><br><span class="line">6) <span class="string">"250"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回指定分数范围的成员</strong></p>
<p><code>zrangebyscore key min max [withscores] [limit offset count]</code></p>
<p><code>zrevrangebyscore key max min [withscores] [limit offset count]</code> </p>
<p>zrangebyscore 按照分数从低到高返回，zrevrangebyscore反之。</p>
<p>withscores 会同时返回每个成员的分数</p>
<p>limit offset count 选项可以限制输出的起始位置和个数</p>
<p>min和max 支持开区间（小括号）和闭区间（中括号），-inf 和 +inf 分别代表无限小和无限大</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE user:ranking 200 +inf withscores</span><br><span class="line"> 1) <span class="string">"frank"</span></span><br><span class="line"> 2) <span class="string">"200"</span></span><br><span class="line"> 3) <span class="string">"tim"</span></span><br><span class="line"> 4) <span class="string">"220"</span></span><br><span class="line"> 5) <span class="string">"martin"</span></span><br><span class="line"> 6) <span class="string">"250"</span></span><br><span class="line"> 7) <span class="string">"tom3"</span></span><br><span class="line"> 8) <span class="string">"252"</span></span><br><span class="line"> 9) <span class="string">"tom"</span></span><br><span class="line">10) <span class="string">"260"</span></span><br><span class="line">127.0.0.1:6379&gt; ZRANGEBYSCORE user:ranking 200 +inf withscores <span class="built_in">limit</span> 2 4</span><br><span class="line">1) <span class="string">"martin"</span></span><br><span class="line">2) <span class="string">"250"</span></span><br><span class="line">3) <span class="string">"tom3"</span></span><br><span class="line">4) <span class="string">"252"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"260"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>返回指定分数范围成员个数</strong></p>
<p><code>zcount key min max</code></p>
</li>
<li><p><strong>删除指定排名内的升序元素</strong></p>
<p><code>zremrangebyrank key start end</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYRANK user:ranking 0 2</span><br><span class="line">(<span class="built_in">integer</span>) 3  <span class="comment">#删除前3个元素</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>删除指定分数范围的成员</strong></p>
<p><code>zremrangebyscore key min max</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZREMRANGEBYSCORE user:ranking (250 +inf  <span class="comment">#将250分以上的成员全部删除，返回结果为成功删除的个数</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>集合间的操作</strong></p>
<ul>
<li><p><strong>交集</strong></p>
<p><code>zinterstore destination numkeys key [key ...] [weights weight] [aggregate sum|min|max]</code></p>
<ul>
<li>destination：交集计算结果保存到这个键</li>
<li>numkeys：需要做交集计算键的个数</li>
<li>key[key…]：需要做交集计算的键</li>
<li>weights weight：每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1。</li>
<li>aggregate sum|min|max：计算成员交集后，分值按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum。</li>
</ul>
<p>下面将对user:ranking:1和user:ranking:2做交集，weights和aggregate使用了默认值，可以看到目标键user:ranking:1_inter_2对分值做了sum操作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd user:ranking:1 1 kris 91 mike 200 frank 220 tim 250 martin 251 tom</span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br><span class="line">127.0.0.1:6379&gt; zadd user:ranking:2 8 james 77 mike 625 martin 888 tom</span><br><span class="line">(<span class="built_in">integer</span>) 4</span><br><span class="line">127.0.0.1:6379&gt; ZINTERSTORE user:ranking:1_inter_2 2 user:ranking:1 user:ranking:2 </span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange user:ranking:1_inter_2 0 -1 withscores</span><br><span class="line">1) <span class="string">"mike"</span></span><br><span class="line">2) <span class="string">"168"</span></span><br><span class="line">3) <span class="string">"martin"</span></span><br><span class="line">4) <span class="string">"875"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"1139"</span></span><br></pre></td></tr></table></figure>

<p>如果想让user:ranking:2的权重变为0.5，并且聚合效果使用max，可以执行如下操作：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZINTERSTORE user:ranking:1_inter_2 2 user:ranking:1 user:ranking:2 weights 1 0.5 aggregate max</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; zrange user:ranking:1_inter_2 0 -1 withscores</span><br><span class="line">1) <span class="string">"mike"</span></span><br><span class="line">2) <span class="string">"91"</span></span><br><span class="line">3) <span class="string">"martin"</span></span><br><span class="line">4) <span class="string">"312.5"</span></span><br><span class="line">5) <span class="string">"tom"</span></span><br><span class="line">6) <span class="string">"444"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>并集</strong></p>
<p><code>zunionstore destination numkeys key [key ...] [weights weight] [aggregate sum|min|max]</code></p>
</li>
</ul>
<p><strong>有序集合命令的时间复杂度</strong></p>
<table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td align="center">zadd key score member [score member …]</td>
<td align="center">O(kxlog(n))，k是添加成员的个数，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zcard key</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">zscore key member</td>
<td align="center">O(1)</td>
</tr>
<tr>
<td align="center">zrank/zrevrank  key member</td>
<td align="center">O(log(n))，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zrem key member [member …]</td>
<td align="center">O(k*log(n))，k是删除成员的个数，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zincrby key increment member</td>
<td align="center">O(log(n))，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zrange/zrevrange  key start end [withscores]</td>
<td align="center">O(log(n)+k)，k是要获取的成员个数，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zrangebyscore/zrevrangebyscore  key  min/max  max/min  [withscores]</td>
<td align="center">O(log(n)+k)，k是要获取的成员个数，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zcount key min max</td>
<td align="center">O(log(n))，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zremrangebyrank key start end</td>
<td align="center">O(log(n)+k)，k是要删除的成员个数，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zremrangebyscore key min max</td>
<td align="center">O(log(n)+k)，k是要删除的成员个数，n是当前有序集合成员个数</td>
</tr>
<tr>
<td align="center">zinterstore destination numkeys key [key …]</td>
<td align="center">O(nxk)+O(mxlog(m))，n是成员数量最小的有序集合成员个数，k是有序集合的个数，m是结果集中成员个数</td>
</tr>
<tr>
<td align="center">zunionstore destination numkeys key [key …]</td>
<td align="center">O(n)+O(mxlog(m))，n是所有有序集合成员个数和，m是结果集中成员个数</td>
</tr>
</tbody></table>
</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Gy</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://teahub.store/2020/05/19/redis/">http://teahub.store/2020/05/19/redis/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://teahub.store" target="_blank">TeaHub</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/img/wechat.jpg" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="post-qr-code__img" src="/img/alipay.jpg" alt="支付寶"/><div class="post-qr-code__desc">支付寶</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="next-post pull-full"><a href="/2020/05/15/git/"><img class="next_cover" src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">git 简介以及使用</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By Gy</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script></body></html>
